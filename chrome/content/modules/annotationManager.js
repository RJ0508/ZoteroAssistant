/**
 * Annotation Manager
 * 
 * Manages PDF annotations created from AI responses
 */

var ZoteroAIAssistant = ZoteroAIAssistant || {};

ZoteroAIAssistant.AnnotationManager = {
  // Annotation colors
  COLORS: {
    translation: "#a7f3d0",  // Green
    explanation: "#bfdbfe",  // Blue
    summary: "#fde68a",      // Yellow
    definition: "#c4b5fd",   // Purple
    default: "#fca5a5"       // Red
  },
  
  /**
   * Save AI response as a PDF annotation
   * @param {object} options
   * @param {number} options.itemID - Zotero item ID
   * @param {string} options.selectedText - The text that was selected
   * @param {string} options.response - AI response to save
   * @param {string} options.actionType - Type of action (translate, explain, etc.)
   * @param {object} options.position - Optional position data
   */
  async saveAsAnnotation(options) {
    const { itemID, selectedText, response, actionType, position } = options;
    
    if (!itemID || !response) {
      Zotero.debug("ZoteroAIAssistant.AnnotationManager: Missing required parameters");
      return null;
    }
    
    try {
      // Get the parent item (should be a PDF attachment)
      const item = await Zotero.Items.getAsync(itemID);
      if (!item) {
        Zotero.debug("ZoteroAIAssistant.AnnotationManager: Item not found");
        return null;
      }
      
      // Find the PDF attachment
      let pdfItem = item;
      if (!item.isPDFAttachment?.()) {
        // Try to find PDF attachment
        const attachments = item.getAttachments();
        for (const attachmentID of attachments) {
          const attachment = await Zotero.Items.getAsync(attachmentID);
          if (attachment && attachment.isPDFAttachment?.()) {
            pdfItem = attachment;
            break;
          }
        }
      }
      
      if (!pdfItem.isPDFAttachment?.()) {
        Zotero.debug("ZoteroAIAssistant.AnnotationManager: No PDF attachment found");
        return null;
      }
      
      // Create annotation
      const color = this.COLORS[actionType] || this.COLORS.default;
      const annotationType = selectedText ? "highlight" : "note";
      
      // Format the comment
      const comment = this.formatAnnotationComment(actionType, response);
      
      // Create the annotation item
      const annotation = new Zotero.Item("annotation");
      annotation.parentID = pdfItem.id;
      annotation.annotationType = annotationType;
      annotation.annotationColor = color;
      annotation.annotationComment = comment;
      
      if (selectedText) {
        annotation.annotationText = selectedText;
      }
      
      // Set position if available
      if (position) {
        annotation.annotationPosition = JSON.stringify(position);
      }
      
      await annotation.saveTx();
      
      Zotero.debug(`ZoteroAIAssistant.AnnotationManager: Created annotation ${annotation.id}`);
      
      return annotation.id;
    } catch (error) {
      Zotero.debug("ZoteroAIAssistant.AnnotationManager: Error creating annotation: " + error);
      return null;
    }
  },
  
  /**
   * Format the annotation comment
   */
  formatAnnotationComment(actionType, response) {
    const prefix = this.getActionPrefix(actionType);
    return `${prefix}\n\n${response}\n\n[Generated by AI Assistant]`;
  },
  
  /**
   * Get action prefix for annotation
   */
  getActionPrefix(actionType) {
    const prefixes = {
      translate: "[AI Translation]",
      explain: "[AI Explanation]",
      define: "[AI Definition]",
      summarize: "[AI Summary]",
      paraphrase: "[AI Paraphrase]",
      default: "[AI Response]"
    };
    return prefixes[actionType] || prefixes.default;
  },
  
  /**
   * Get all AI-generated annotations for an item
   */
  async getAIAnnotations(itemID) {
    if (!itemID) return [];
    
    try {
      const item = await Zotero.Items.getAsync(itemID);
      if (!item) return [];
      
      // Find PDF attachment
      let pdfItem = item;
      if (!item.isPDFAttachment?.()) {
        const attachments = item.getAttachments();
        for (const attachmentID of attachments) {
          const attachment = await Zotero.Items.getAsync(attachmentID);
          if (attachment && attachment.isPDFAttachment?.()) {
            pdfItem = attachment;
            break;
          }
        }
      }
      
      if (!pdfItem.isPDFAttachment?.()) return [];
      
      // Get annotations
      const annotationIDs = pdfItem.getAnnotations?.() || [];
      const annotations = [];
      
      for (const annID of annotationIDs) {
        const ann = await Zotero.Items.getAsync(annID);
        if (ann) {
          const comment = ann.annotationComment || "";
          // Check if it's an AI-generated annotation
          if (comment.includes("[Generated by AI Assistant]") || 
              comment.includes("[AI Translation]") ||
              comment.includes("[AI Explanation]") ||
              comment.includes("[AI Definition]") ||
              comment.includes("[AI Summary]")) {
            annotations.push({
              id: ann.id,
              type: ann.annotationType,
              text: ann.annotationText,
              comment: ann.annotationComment,
              color: ann.annotationColor,
              dateAdded: ann.dateAdded
            });
          }
        }
      }
      
      return annotations;
    } catch (error) {
      Zotero.debug("ZoteroAIAssistant.AnnotationManager: Error getting annotations: " + error);
      return [];
    }
  },
  
  /**
   * Delete an AI annotation
   */
  async deleteAnnotation(annotationID) {
    try {
      const annotation = await Zotero.Items.getAsync(annotationID);
      if (annotation) {
        await annotation.eraseTx();
        return true;
      }
      return false;
    } catch (error) {
      Zotero.debug("ZoteroAIAssistant.AnnotationManager: Error deleting annotation: " + error);
      return false;
    }
  },
  
  /**
   * Update annotation comment
   */
  async updateAnnotation(annotationID, newComment) {
    try {
      const annotation = await Zotero.Items.getAsync(annotationID);
      if (annotation) {
        annotation.annotationComment = newComment;
        await annotation.saveTx();
        return true;
      }
      return false;
    } catch (error) {
      Zotero.debug("ZoteroAIAssistant.AnnotationManager: Error updating annotation: " + error);
      return false;
    }
  }
};
